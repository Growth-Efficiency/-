# 스프링 핵심 원리 - 기본편
Inflearn 김영한님 강의 : 스프링 핵심 원리 - 기본편

※ 1일차 ※

IOC : 제어의 역전

SOLID
SRP : 단일책임원칙(Single Responsibility Principle)
- 중요한 기준은 변경이다! 변경이 있을때 파급 효과가 적으면 잘 따른것이다.
- 한 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임이라는 것은 모호하다.
- ex) UI변경, 객체의 생성과 사용을 분리하는것.

OCP : 개방-폐쇄 원칙(Open / Closed Principle)
- 확장에는 열려있고 변경에는 닫혀있어야 한다.
- 다형성을 활용할것.
* 다형성을 사용했지만 OCP 원칙을 지킬 수가 없음.
* 이때문에 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요 = 스프링 컨테이너(IOC, DI 등)
- 인터페이스를 구현한 새로운 클래스를 만들어서 새로운 기능을 또 구현가능.


LSP : 리스코프 치환 원칙(Liskov Substitution Principle)
- 예를 들어 엑셀(인터페이스)은 밟으면(구현) 앞으로만 가야함.(뒤로가면 안됨. 기능보장하기)
- 객체는 프로그램의 정확성을 깨지않고 하위 타입의 인스턴스를 바꿀 수 있어야 한다.
- 하위 클래스는 인터페이스의 규약을 다 지켜야함.

ISP : 인터페이스 분리 원칙(Interface segregation principle)
- 범용 인터페이스 하나보다 여러개의 인터페이스가 낫다.
- 정비 인터페이스의 정비사 기능을 바꾸는데 운전자 기능이 바뀌면 안됨.
- 인터페이스를 분리하면 명확해지고 대체 가능성이 높아진다.

DIP : 의존관계 역전 원칙(Dependency Inversion Principle)
- 로미오를 연기하는 사람이 줄리엣만 알면 되지 줄리엣의 배우까지 알필요는 없음.
- 구현 클래스에 의존하지 말고 인터페이스에 의존해야 한다.

개발방법 정리
- 이상적인 개발은 모든설계에 인터페이스를 부여하는것이 좋다.
* 배보다 배꼽이 더 클때도 있음.
* 기능을 확장할 가능성이 없으면 구체 클래스를 바로 하고 나중에 인터페이스로 리팩토링해도 됌.
- 모든 역할과 구현을 분리하자.

-------------------------------------------------------------------------------------------------------------------------------------------

※ 2일차 ※

간단한 개발요청에 따른 개발

-------------------------------------------------------------------------------------------------------------------------------------------

※ 3일차 ※

Ctrl + Shift + T : 테스트파일을 쉽게 만들수 있음.

IOC(Inversion of Control) : 제어의 역전
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 제어하는 것을 제어의 역전이라고 한다.

DI(Dependency Injection) : 의존관계 주입
실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가
연결되는 것을 DI라고 한다.

IOC컨테이너 or DI 컨테이너
객체를 생성하고 관리하면서 의존관계를 연결해주는것.

프레임워크 vs 라이브러리의 차이
내가 작성한 코드를 대신 제어하고 실행하면 프레임워크이고,
내가 작성한 코드를 내가 직접 제어의 흐름을 담당한다면 라이브러리이다.

-------------------------------------------------------------------------------------------------------------------------------------------

※ 4일차 ※

스프링 컨테이너에 빈 객체 등록하는법.

-> 먼저 AppConfig.class에 구성 정보를 담는다.(@Bean)
-> DI가 필요한 구현 위치에 new AnnotationConfigApplicationContext(AppConfig.class)를 하여 스프링 컨테이너를 생성해준다.
(이때 AppConfig.class를 구성 정보로 지정했다.)
-> 그러면 스프링 컨테이너를 파라미터로 넘어온 설정 클래스 정보를(AppConfig.class의 @Bean 들) 사용하여 스프링 빈을 등록한다.
* 항상 빈 이름은 다르게 부여해야 하고 @Bean(name="test")처럼 변경 가능하며 빈만 사용시 메서드 명으로 생성된다.

iter : 자동으로 리스트 또는 배열을 for문(:) 만들어줌.
itar : 자동으로 리스트 도는 배열을 for문(i++)으로 만들어줌
Ctrl + Alt + V : 값이 담긴 값을 선언하고 사용하면 자동으로 저장 할 타입, 변수명을 앞에 만들어줌.

AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
ac.getBeanDefinitionNames(); // 모든 빈 이름을 가져온다.
ac.getBean(beanDefinitionName); // 빈 이름으로 빈 객체를 조회한다.

BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); // 빈 이름으로 메타 데이터 정보 받아오기.
* @Bean 하나당 각각 하나씩 메타정보가 생성된다.

BeanDefinition.ROLE_APPLICATION // 일반적으로 사용자가 정의한 빈
BeanDefinition.ROLE_INFRASTRUCTURE // 스프링이 내부에서 사용하는 빈

@Test시 일부로 설계한 예외를 터트리는지 확인하는 방법도 있다.
-> Assertions.assertThrows(NoSuchBeanDefinitionException.class, () -> ac.getBean("ABC", MemberService.class));

자바 객체는 모든게 Object 타입이므로 Object.class로 조회하면 모든 @Bean이 나온다.

★ BeanFactory
스프링 컨테이너의 최상위 인터페이스이다.
스프링 빈을 관리하고 조회한다.
getBean을 제공한다.
★ ApplicationContext
Beanfactory의 모든 기능을 상속받아서 제공한다. (빈 관리기능 + 편리한 부가기능 제공)
그래서 BeanFactory를 직접 사용하지 않고 부가기능이 추가된 ApplicationContext를 사용한다.
BeanFactory와 ApplicationContext 둘다 스프링 컨테이너라고 한다.


-------------------------------------------------------------------------------------------------------------------------------------------

※ 5일차 ※

스프링 컨테이너는 싱글톤 컨테이너 역할을 하여 싱글톤 레지스트리라 한다.
싱글톤 패턴을 위한 지저분한 코드를 넣어주지 않아도 된다.(private static 인스턴스 생성, private 생성자 등)
DIP, OCP, 테스트 private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.

* 싱글톤 방식의 주의점
  싱글톤 패턴이든 스프링 같이 싱글톤 컨테이너를 사용하든 객체 인스턴스를 하나만 생성해서 공유하기에 싱글톤
  객체는 상태를 유지(Stateful)하게 설계하면 안된다.
  무상태(Stateless)로 존재해야 한다.
    - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
    - 가급적 읽기만 해야된다.
    - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
      스프링 @Bean의 필드에 공유 값을 설정하면 절때 안된다! (price 등)

@Configuration 없이 @Bean 만 사용해도 스프링 빈으로 등록이 되지만 싱글톤이 보장 되지 않는다.
-> 해결방법으로는 @Autowired(의존성 주입)를 사용하는 법도 있다.
-> 그냥 스프링 설정 정보에는 고민말고 @Configuration을 사용해도 좋다.