# [스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/)

## EJB -> SPRING 으로 넘어가게 된 배경

### EJB (Enterprise Java Beans)

- 2000년대 초반까지 자바 표준 기술
- 지금으로 따지면 Spring + JPA 등 종합으로 합친 느낌의 기술
- 당시에는 오픈소스를 못 믿는 문화가 많았기에 표준 기술로 되어 있는 EJB 를 많이 씀 (금융권 등)
- 현재 JPA 가 당시에는 엔티티빈이라는 기술이 있었음. (EJB 에 포함되어 있음)

#### 단점

- 복잡한 개발환경.
- 한 번 실행하는 데에 드는 시간이 오래 걸린다.
- EJB 가 제공하는 인터페이스를 다 구현하며, 의존적으로 개발이 진행 됨.
- 특정 환경, 기술에 종속적인 코드가 만들어지게 된다.
- 컨테이너 안에서만 동작할 수 있는 객체구조를 가진다.
- 자동화된 테스트가 매우 어렵거나 불가능에 가깝다.
- 객체지향적이지 않다.

### SPRING

- 2002년 로드 존슨이라는 개발자가 EJB 의 단점을 책으로 작성하며,  
  EJB 가 없이 개발할 수 있음을 30,000라인 이상의 기반 기술을 예제 코드로 선보였음.
- 해당 코드에 현재 스프링 핵심 개념과 기반 코드들이 들어가 있다.  
  예) BeanFactory, ApplicationContext, POJO, 제어의 역전, 의존관계 주입
- 전통적인 J2EE(EJB) 라는 겨울을 지나 새로운 봄을 맞이했다는 뜻으로 지었다.

### Hibernate (하이버네이트)

=======

### Hibernate (하이버네이트)

- EJB 엔티티빈이 불편해서 만든 기술.
- 하이버네이트를 거의 그대로 JPA 라는 자바 표준 인터페이스를 만들게 됨.
- 하이버네이트는 그러한 JPA 를 구현한 구현체이며, 현재 가장 많이 쓰는 JPA 구현체.

<<<<<<< HEAD
## SPRING FRAMEWORK, SPRING BOOT

### SPRING

=======

## SPRING FRAMEWORK, SPRING BOOT

### SPRING

- 핵심기술: 스프링 DI 컨테이너, AOP, 이벤트 등
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비

### SPRING BOOT
<<<<<<< HEAD

- SPRING 단점을 보완하여 편리하게 사용할 수 있도록 지원함.
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성.  
  Tomcat 과 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨.
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
    - 라이브러리들을 여러 개를 한 번에 가져올 수 있도록 잘 구성되어 있음.
- 스프링과 3rd parth(외부) 라이브러리 자동 구성
    - 스프링 버전과 외부 라이브러리 버전의 조합과 궁합이 잘 맞는 걸 지정해두었음.
=======
- SPRING 단점을 보완하여 편리하게 사용할 수 있도록 지원함.
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성.  
  Tomcat 과 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨.
- 손쉬운 빌드 구성을 위한 starter 종속성 제공  
  - 라이브러리들을 여러 개를 한 번에 가져올 수 있도록 잘 구성되어 있음.
- 스프링과 3rd parth(외부) 라이브러리 자동 구성  
  - 스프링 버전과 외부 라이브러리 버전의 조합과 궁합이 잘 맞는 걸 지정해두었음.

- 매트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

### 스프링 단어

- 스프링이라는 단어는 문맥에 따라 다르게 사용된다.
    - 스프링 DI 컨테이너 기술
    - 스프링 프레임워크
    - 스프링 부트, 스프링 프레임워크 등을 모두 포함한 생태계

### 스프링 핵심

- 좋은 객체지향 애플리케이션을 개발할 수 있도록 도와주는 프레임워크

## 객체지향 프로그래밍

- 객체들을 조립해서 사용하는 객체들의 모임. 각각의 객체는 메세지를 통해 소통을 하며 데이터를 처리할 수 있다.
- 인터페이스만 잘 작성하면 협업에 매우 특화되기 때문에 대규포 소프트웨어 개발에 많이 사용된다.

## 다형성 (Polymorphism)

- 역할과 구현을 분리하는 것 역할 1 : 구현 N
- 역할 (인터페이스)을 정의해두면 구현(클래스)이 바뀌어도 영향을 주지 않도록 설계
=======
- 스프링이라는 단어는 문맥에 따라 다르게 사용된다.
  - 스프링 DI 컨테이너 기술
  - 스프링 프레임워크
  - 스프링 부트, 스프링 프레임워크 등을 모두 포함한 생태계

### 스프링 핵심
- 좋은 객체지향 애플리케이션을 개발할 수 있도록 도와주는 프레임워크

## 객체지향 프로그래밍
- 객체들을 조립해서 사용하는 객체들의 모임. 각각의 객체는 메세지를 통해 소통을 하며 데이터를 처리할 수 있다.  
- 인터페이스만 잘 작성하면 협업에 매우 특화되기 때문에 대규포 소프트웨어 개발에 많이 사용된다.  

## 다형성 (Polymorphism)
- 역할과 구현을 분리하는 것 역할 1 : 구현 N  
- 역할 (인터페이스)을 정의해두면 구현(클래스)이 바뀌어도 영향을 주지 않도록 설계  
- 사용하는 곳에서는 구현이 무엇인지 상관이 없도록 설계
- 내부 구조가 변경되어도 영향이 없도록 설계
- 가장 중요한건 **역할** 이 중요하다.
- 구현 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있어야 한다.
- 협력이라는 객체 사이의 관계에서 시작
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

- SRP : 단일 책임 원칙 (Single responsibility principle)
    - 하나의 클래스는 하나의 책임만을 가져야 한다.
    - 변경이 있을 때 파급 효과가 적다면 단일 책임 원칙을 잘 따른 것이다.
- OCP : 개방-폐쇄 원칙 (Open / closed principle)
    - 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
    - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
    - 다형성을 활용하는 것.
    - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
- LSP : 리스코프 치환 원칙 (Liskov substitution principle)
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
    - 하위 클래스는 인터페이스 규약을 다 지켜야 한다.
    - 인터페이스를 구현한 구현체를 믿고 사용하려면, 이 원칙이 필요하다.
- ISP : 인터페이스 분리 원칙 (Interface segregation principle)
    - 적당한 크기의 인터페이스를 분리하는 것이 중요하다.
    - 인터페이스가 명확해지고, 대체 가능성이 높아진다.
- DIP : 의존관계 역전 원칙 (Dependency inversion principle)
    - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
    - 구현 클래스가 아닌 인터페이스에 의존할 수 있게 설계해야 한다.

### 객체지향 정리 핵심

=======
- SRP : 단일 책임 원칙 (Single responsibility principle)
  - 하나의 클래스는 하나의 책임만을 가져야 한다.  
  - 변경이 있을 때 파급 효과가 적다면 단일 책임 원칙을 잘 따른 것이다.  
- OCP : 개방-폐쇄 원칙 (Open / closed principle)
  - 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.  
  - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
  - 다형성을 활용하는 것.
  - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
- LSP : 리스코프 치환 원칙 (Liskov substitution principle)
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.  
  - 하위 클래스는 인터페이스 규약을 다 지켜야 한다.
  - 인터페이스를 구현한 구현체를 믿고 사용하려면, 이 원칙이 필요하다.
- ISP : 인터페이스 분리 원칙 (Interface segregation principle)
  - 적당한 크기의 인터페이스를 분리하는 것이 중요하다.
  - 인터페이스가 명확해지고, 대체 가능성이 높아진다.
- DIP : 의존관계 역전 원칙 (Dependency inversion principle)
  - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.  
  - 구현 클래스가 아닌 인터페이스에 의존할 수 있게 설계해야 한다.

### 객체지향 정리 핵심

- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성 만으로는 **OCP, DIP**를 지킬 수 없다.

### 스프링에서 OCP, DIP 를 지키는 방법

- 다형성 + OCP, DIP를 가능하게 하는 기술
    - DI (Dependency Injection) : 의존관계, 의존성 주입
    - DI 컨테이너
- 클라이언트 코드의 변경 없이 기능 확장

## IOC, DI, 그리고 컨테이너

### 제어의 역전 IoC (Inversion of Control)

- 제어의 흐름 외부에 위임하여 (AppConfig) 객체의 생성, 연결, 구현을 분리하여  
  구현 클래스에서는 구현 역할만 담당하도록 만든다.

### 프레임워크 vs 라이브러리

- 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다. (Junit)
- 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.

### 의존관계 주입 DI (Dependency Injection)

- 인터페이스(추상화)에만 의존하여 실제 구현 객체가 어떤 건지 모르게 한다.
- 구현 객체는 외부에서 주입해주는 방식을 말한다.
- 정적인 클래스 의존 관계, 실행 시점 결정되는 동적인 객체(인스턴스) 의존관계 둘을 분리해서 생각한다.

#### 정적인 클래스 의존관계

- import 되어 있는 관계
- 클래스 다이어그램에 연결 되어 있는 의존 관계를 말한다.

#### 동적인 객체 인스턴스 의존 관계

- 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계.
- 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서  
  클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라 한다.
- 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결한다.
- 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는  
  대상의 타입 인스턴스를 변경할 수 있다.
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고,  
  동적인 객체 인스턴스 의존 관계를 쉽게 변경할 수 있다.

### IoC 컨테이너, DI 컨테이너

- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는것을  
  IoC 컨테이너 또는 DI 컨테이너라 한다.
- 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.
- 또는 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.

### 스프링 컨테이너

- **ApplicationContext** 를 스프링 컨테이너라 한다.
- **@Configuration** 이 붙은 AppConfig 를 설정 정보로 사용한다.
- **@Bean** 이 붙은 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 등록한다.
- 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- 스프링 빈은 **@Bean**이 붙은 메서드 명을 스프링 빈의 이름으로 사용한다.

참고
> 스프링 컨테이너를 **BeanFactory**, **ApplicationContext** 를 구분해서 이야기 한다.  
> **BeanFactory**를 직접 사용하는 경우는 거의 없으므로 일반적으로 **ApplicationContext**를 스프링 컨테이너라 한다.

### BeanFactory

- 스프링 컨테이너의 최상위 인터페이스.
- 스프링 빈을 관리하고 조회하는 역할을 담당
- getBean() 제공

### ApplicationContext

- BeanFactory 기능을 모두 상속받아서 제공
- 부가 기능이 추가되어 있다.
- MessageSource
    - 메시지소스를 활용한 국제화 기능
- EnvironmentCapable
    - 환경 변수
    - 로컬, 개발, 운영 등을 구분해서 처리
- ApplicationEventPublisher
    - 애플리케이션 이벤트
    - 이벤트를 발행하고 구독하는 모델을 편리하게 지원
- ResourceLoader
    - 편리한 리소스 조회
    - 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

#### BeanFactory / ApplicationContext 정리

- ApplicationContext 는 BeanFactory 의 기능을 상속 받는다.
- BeanFactory 를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext 를 사용한다.
- BeanFactory 나 ApplicationContext 를 스프링 컨테이너라 한다.

### BeanDefinition - 스프링 빈 설정 메타 정보

- 다양한 설정 형식을 지원할 수 있는 이유는 BeanDefinition 이라는 추상화가 있기 때문이다.
- 스프링 빈을 등록하는 방법은 직접 등록하는 방법(xml)과 팩토리 빈을 통해서 등록하는 방법이 있다.
- 일반적으로 자바 코드로 등록하는 방법은 팩토리 빈을 통하는 방법이다.
=======
- 다형성 + OCP, DIP 를 가능하게 하는 기술
  - DI (Dependency Injection) : 의존관계, 의존성 주입
  - DI 컨테이너
- 클라이언트 코드의 변경 없이 기능 확장

## 싱글톤 컨테이너

### 싱글톤 패턴
- 객체를 하나만 생성하여 모든 곳에서 하나만 사용한다.
- private 생성자로 외부에서 생성하는 것을 막는다.
- 스프링에서는 빈 등록 시 기본으로 싱글톤 패턴을 사용한다.

#### 싱글톤 패턴 문제점
- 구현하는 코드 자체가 많이 들어간다.
- 의존관계상 클라이언트가 구체 클래스에 의존한다. -> DIP 를 위반한다.
- 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
- 유연하게 테스트하기가 어렵다.
- 내부 속성을 변경하거나 초기화 하기 어렵다.
- private 생성자로 자식 클래스를 만들기 어렵다.
- 결론적으로 유연성이 떨어진다.
- 안티패턴으로 불리기도 한다.

### 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 이늣턴스를 싱글톤으로 관리한다.
- 스프링 빈이 바로 싱글톤으로 관리되는 빈이다.

#### 스프링 컨테이너 빈
- 기본 빈 등록 방식은 싱글톤 방식으로 사용하지만, 요청할 때마다 새로운 객체를 생성해서   
  반환하는 기능도 제공한다.

### 싱글톤 방식의 주의점
- 하나의 같은 객체 인스턴스를 여러 클라이언트에서 공유하기 때문에 상태 값을 가지면 안된다.
- 무상태(stateless)로 설계해야 한다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 읽기만 가능해야 한다.
  - 필드 대신 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
- 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다.

### @Configuration ??
- @Configuration 을 사용 시 바이트코드를 조작하여 새로운 객체를 만들고,  
  해당 객체를 스프링 컨테이너에 등록한다.
- @Configuration 내에서 @Bean 등록 시 기존에 빈 등록이 되어 있는 메소드를 호출하면  
  이미 등록된 인스턴스를 불러서 주입해준다.
- @Bean 만 사용할 시 스프링 빈에 등록이 되지만, 싱글톤이 보장되진 않는다.
- 스프링 설정 정보는 항상 "@Configuration"을 사용하자.

### @ComponentScan
- excludeFilters : ComponentScan 에서 제외를 세팅
- basePackages : 스캔 범위 패키지를 설정한다. (디폴트는 @ComponentScan 패키지부터 시작한다.)

#### FilterType 옵션

ANNOTATION: 기본 값, 애노테이션을 인식해서 동작한다.
  - ex) org.example.SomeAnnotation
ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
  - ex) org.example.SomeClass
ASPECTJ: AspectJ 패턴 사용
  - ex) org.example..*Service+
REGEX: 정규 표현식
  - ex) org\.example\.Default.*
CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리
  - ex) org.example.MyTypeFilter

### 수동 빈 등록 vs 자동 빈 등록
- 수동 빈 등록이 우선순위를 가져가서 자동 빈을 오버라이딩 한다.
- 스프링 부트에서는 이 설정을 false 로 하여 실행 시 에러가 발생하도록 변경했다.
- 개발은 혼자하는 것이 아니라 여러 명이서 하는거기 때문에 이러한 애매한 상황은 안 만드는게 최고다.

### 의존관계 주입 방법

#### 생성자 주입
- 생성자를 통해 의존 관계를 주입하는 방법
- 생성하는 시점에 딱 1번만 호출되는 것이 보장이 된다.
- final 키워드를 통해 불변, 필수로 만들어서 사용하자.
- 생성자가 딱 1개만 있으면 @Autowired 를 생략해도 자동 주입이 된다.
  - 물론 스프링 빈에서만 해당된다.

#### 수정자 주입
- setter 라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법
- 특징
  - 선택, 변경 가능성이 있는 의존관계에 사용
  - 자바 빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법
  - @Autowired 의 디폴트는 주입할 대상이 없으면 오류를 발생시킨다.
  - @Autowired(required - false) 로 지정하면 주입할 대상이 없어도 동작이 가능하다.

#### 필드 주입
- 필드에 바로 주입하는 방법
- private 필드도 주입이 가능하다.
- 특징
  - 코드가 간결해서 예전에는 많이 사용했지만, 외부에서 변경이 불가능하기 때문에  
    테스트하기 힘들다는 치명적인 단점이 있다.
  - DI 프레임워크가 없으면 아무것도 할 수 없다.
  - 사용하지 말자.
    - 테스트 코드에서는 사용해도 괜찮다.
    - 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용.
    
#### 일반 메서드 주입
- 일반 메서드를 통해서 주입 받을 수 있다.
- 한번에 여러 필드를 주입받을 수 있다.
- 생성자 주입, 수정자 주입과 비슷한 원리이기 때문에 보통 사용하지 않는다.


### @Autowired 옵션 처리
- @Autowired(required=false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출이 안됨.
- @Nullable : 자동 주입할 대상이 없으면 null 이 입력됨.
- Optional<> : 자동 주입할 대상이 없으면 Optional.empty 가 셋팅 됨.

### 의존관계 주입 중 생성자 주입을 사용해야 하는 이유
- 불변
  - 대부분 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 변경할 일이 거의 없다.
  - 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다. (불변해야 한다.)
  - 수정자 주입을 사용하면, set 메서드를 public 으로 열어야 한다.
  - 누군가 실수로 변경 가능하고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
  - 생성자 주입은 객체 생성 시 딱 1번만 호출되므로 이후 호추로디는 일이 없다.
  - 따라서 불변하게 설계가 가능하다.
- 누락
  - 프레임워크 없이 순수 자바코드로 실행할 시 수정자 의존관계 경우 누락이 발생할 수 있다.
- final 키워드는 생성자 주입 방식에서만 사용할 수 있다.
- 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 살릴 수 있다.
- 기본적으로 생성자 주입을 선택하고, 필수 값이 아닌 경우에 수정자 주입 방식을 옵션으로 사용할 수 있다.
  

- 항상 생성자 주입을 선택해라!
- 가끔 옵션이 필요하면 수정자 주입을 선태갷라!
- 필드 주입은 테스트에 어려움이 있고, 프레임워크에 의존적이기 때문에 사용하지 않는게 좋다.

### 조회 대상 빈이 2개 이상일 때 해결 방법
- @Autowired 필드 명 또는 파라미터 명을 빈 이름으로 변경하면 매칭해준다.
- @Quilifier 에 이름을 준 후 사용하는 곳에서 해당 이름으로 불러서 사용할 수 있다.
- @Primary 우선순위를 정할 수 있다. (우선순위를 둘 컴포넌트 위에 붙인다.)

### 빈 등록 자동 vs 수동
- 기본으로는 편리한 자동 등록을 사용하자.
- 기술 지원 객체(AOP) 경우 수동 등록을 생각해보자.
- 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자.
  - 아니면 같은 패키지에 묶자!

## 빈 생명주기

### 빈 생명주기 콜백
- 스프링 빈의 이벤트 라이프 사이클
  - 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백  
  -> 사용 -> 소멸 전 콜백 -> 스프링 종료
    - 생성자 주입일 경우에는 빈 생성 당시에 의존관계 주입이 대부분 일어난다.
    - 해당 라이프사이클은 싱글톤 빈 방식에 해당된다.
  - 초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
  - 소멸전 콜백: 빈이 소멸되기 직전에 호출


- 객체의 생성과 초기화를 분리하자
  - 생성자는 필수정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다.  
  - 반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행한다.  
  - 따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는  
    객체를 생성하는 부분과 초기화하는 부분을 명화하게 나누는 것이 유지보수 관점에서 좋다.
  - 물론, 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는  
    생성자에서 한 번에 다 처리하는 게 더 나을 수 있다.

### 빈 콜백 - 인터페이스
- InitializingBean - afterPropertiesSet(): 초기화 콜백
- DisposableBean - destroy(): 종료 콜백
- 단점
  - 스프링 전용 인터페이스로 스프링에 의존적이다.
  - 초기화, 소멸 메소드 명을 변경할 수 없다.
  - 내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.
- 현재 거의 사용하지 않는 방식이다.