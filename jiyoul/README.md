# 스프링 핵심 원리 - 기본편
Inflearn 김영한님 강의 : 스프링 핵심 원리 - 기본편

※ 1일차 ※

IOC : 제어의 역전

SOLID
SRP : 단일책임원칙(Single Responsibility Principle)
- 중요한 기준은 변경이다! 변경이 있을때 파급 효과가 적으면 잘 따른것이다.
- 한 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임이라는 것은 모호하다.
- ex) UI변경, 객체의 생성과 사용을 분리하는것.

OCP : 개방-폐쇄 원칙(Open / Closed Principle)
- 확장에는 열려있고 변경에는 닫혀있어야 한다.
- 다형성을 활용할것.
* 다형성을 사용했지만 OCP 원칙을 지킬 수가 없음.
* 이때문에 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요 = 스프링 컨테이너(IOC, DI 등)
- 인터페이스를 구현한 새로운 클래스를 만들어서 새로운 기능을 또 구현가능.


LSP : 리스코프 치환 원칙(Liskov Substitution Principle)
- 예를 들어 엑셀(인터페이스)은 밟으면(구현) 앞으로만 가야함.(뒤로가면 안됨. 기능보장하기)
- 객체는 프로그램의 정확성을 깨지않고 하위 타입의 인스턴스를 바꿀 수 있어야 한다.
- 하위 클래스는 인터페이스의 규약을 다 지켜야함.

ISP : 인터페이스 분리 원칙(Interface segregation principle)
- 범용 인터페이스 하나보다 여러개의 인터페이스가 낫다.
- 정비 인터페이스의 정비사 기능을 바꾸는데 운전자 기능이 바뀌면 안됨.
- 인터페이스를 분리하면 명확해지고 대체 가능성이 높아진다.

DIP : 의존관계 역전 원칙(Dependency Inversion Principle)
- 로미오를 연기하는 사람이 줄리엣만 알면 되지 줄리엣의 배우까지 알필요는 없음.
- 구현 클래스에 의존하지 말고 인터페이스에 의존해야 한다.

개발방법 정리
- 이상적인 개발은 모든설계에 인터페이스를 부여하는것이 좋다.
* 배보다 배꼽이 더 클때도 있음.
* 기능을 확장할 가능성이 없으면 구체 클래스를 바로 하고 나중에 인터페이스로 리팩토링해도 됌.
- 모든 역할과 구현을 분리하자.

-------------------------------------------------------------------------------------------------------------------------------------------

※ 2일차 ※

간단한 개발요청에 따른 개발

-------------------------------------------------------------------------------------------------------------------------------------------

※ 3일차 ※

Ctrl + Shift + T : 테스트파일을 쉽게 만들수 있음.

IOC(Inversion of Control) : 제어의 역전
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 제어하는 것을 제어의 역전이라고 한다.

DI(Dependency Injection) : 의존관계 주입
실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가
연결되는 것을 DI라고 한다.

IOC컨테이너 or DI 컨테이너
객체를 생성하고 관리하면서 의존관계를 연결해주는것.

프레임워크 vs 라이브러리의 차이
내가 작성한 코드를 대신 제어하고 실행하면 프레임워크이고,
내가 작성한 코드를 내가 직접 제어의 흐름을 담당한다면 라이브러리이다.

-------------------------------------------------------------------------------------------------------------------------------------------

※ 4일차 ※

스프링 컨테이너에 빈 객체 등록하는법.

-> 먼저 AppConfig.class에 구성 정보를 담는다.(@Bean)
-> DI가 필요한 구현 위치에 new AnnotationConfigApplicationContext(AppConfig.class)를 하여 스프링 컨테이너를 생성해준다.
(이때 AppConfig.class를 구성 정보로 지정했다.)
-> 그러면 스프링 컨테이너를 파라미터로 넘어온 설정 클래스 정보를(AppConfig.class의 @Bean 들) 사용하여 스프링 빈을 등록한다.
* 항상 빈 이름은 다르게 부여해야 하고 @Bean(name="test")처럼 변경 가능하며 빈만 사용시 메서드 명으로 생성된다.

iter : 자동으로 리스트 또는 배열을 for문(:) 만들어줌.
itar : 자동으로 리스트 도는 배열을 for문(i++)으로 만들어줌
Ctrl + Alt + V : 값이 담긴 값을 선언하고 사용하면 자동으로 저장 할 타입, 변수명을 앞에 만들어줌.

AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
ac.getBeanDefinitionNames(); // 모든 빈 이름을 가져온다.
ac.getBean(beanDefinitionName); // 빈 이름으로 빈 객체를 조회한다.

BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); // 빈 이름으로 메타 데이터 정보 받아오기.
* @Bean 하나당 각각 하나씩 메타정보가 생성된다.

BeanDefinition.ROLE_APPLICATION // 일반적으로 사용자가 정의한 빈
BeanDefinition.ROLE_INFRASTRUCTURE // 스프링이 내부에서 사용하는 빈

@Test시 일부로 설계한 예외를 터트리는지 확인하는 방법도 있다.
-> Assertions.assertThrows(NoSuchBeanDefinitionException.class, () -> ac.getBean("ABC", MemberService.class));

자바 객체는 모든게 Object 타입이므로 Object.class로 조회하면 모든 @Bean이 나온다.

★ BeanFactory
스프링 컨테이너의 최상위 인터페이스이다.
스프링 빈을 관리하고 조회한다.
getBean을 제공한다.
★ ApplicationContext
Beanfactory의 모든 기능을 상속받아서 제공한다. (빈 관리기능 + 편리한 부가기능 제공)
그래서 BeanFactory를 직접 사용하지 않고 부가기능이 추가된 ApplicationContext를 사용한다.
BeanFactory와 ApplicationContext 둘다 스프링 컨테이너라고 한다.


-------------------------------------------------------------------------------------------------------------------------------------------

※ 5일차 ※

스프링 컨테이너는 싱글톤 컨테이너 역할을 하여 싱글톤 레지스트리라 한다.
싱글톤 패턴을 위한 지저분한 코드를 넣어주지 않아도 된다.(private static 인스턴스 생성, private 생성자 등)
DIP, OCP, 테스트 private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.

* 싱글톤 방식의 주의점
  싱글톤 패턴이든 스프링 같이 싱글톤 컨테이너를 사용하든 객체 인스턴스를 하나만 생성해서 공유하기에 싱글톤
  객체는 상태를 유지(Stateful)하게 설계하면 안된다.
  무상태(Stateless)로 존재해야 한다.
    - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
    - 가급적 읽기만 해야된다.
    - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
      스프링 @Bean의 필드에 공유 값을 설정하면 절때 안된다! (price 등)

@Configuration 없이 @Bean 만 사용해도 스프링 빈으로 등록이 되지만 싱글톤이 보장 되지 않는다.
-> 해결방법으로는 @Autowired(의존성 주입)를 사용하는 법도 있다.
-> 그냥 스프링 설정 정보에는 고민말고 @Configuration을 사용해도 좋다.

-------------------------------------------------------------------------------------------------------------------------------------------

※ 6일차 ※

@ComponentScan
@Component가 붙은 클래스의 데이터들을 쫙 끌어서 빈에 등록해줌.
컴포넌트 스캔중 스캔되지 않고 싶은 데이터도 선택 할 수 있으나 평소에 잘 쓰지 않는게 좋음.
basePackages = "hello.core" 이렇게 탐색할 패키지의 시작 위치를 지정할 수 있음.
* 기본적으로 basePackages를 지정하지 않으면 @ComponentScan이 붙은 클래스의 패키지가 시작위치가 되므로
  프로젝트 최상단에 설정 정보 클래스를 두는게 좋다.

ConPonentScan의 기본 대상
- @Component : 컴포넌트 스캔에 사용.
- @Controller : 스프링 MVC 컨트롤러에서 사용.
- @Service : 스프링 비즈니스 로직에서 사용.
- @Repository : 스프링 데이터 접근 계층에서 사용. / 데이터 계층 예외를 스프링 예외로 변환 해준다.
- @Configuration : 스프링 설정 정보에서 사용. / 스프링 빈이 싱글톤을 유지 하도록 추가 처리를 해준다.

includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다.
excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.


여러 애노테이션을 모아서 사용하는 기능은 자바가 아니라 스프링이 지원하는 기능이다.


-------------------------------------------------------------------------------------------------------------------------------------------

※ 7일차 ※

생성자가 하나만 있으면 @Autowired가 생략되어도 들어간다!

일반적으로 의존 관계 주입은 생성자 주입, 수정자(setter) 주입만 사용한다.

왠만하면 생성자 주입으로 하는것이 좋다.
-> final로 생성하여 비어있는 값이 들어갈 일도 없고 테스트 용도로도 용이하다.

롬복 추가시에 꼭 build.gradle에도 추가하고. 플러그인도 lombok 받아주고.
Settings -> Build, Execution, Deployment -> compiler -> Annotation Processors에서
Enable annotation processiong 을 체크해주어야 한다.

롬복의 기능
@Getter @Setter : get, set을 자동으로 만들어준다
@ToString : 해당 클래스를 출력시 String 형태로 보기 쉽게 출력해준다.
@RequiredArgsConstructor : 비어있지 않는 객체(final)의 생성자를 자동으로 생성해주고 의존 주입해준다.(단일 생성자라서)

@Autowired때 조회된 빈이 2개 이상 일때. (DiscountPolicy의 FixDiscountPolicy , RateDiscountPolicy)
-> 타입 매칭시 2개 이상이면 필드명(파라미터 이름)과 동일한것으로 주입시킨다.
-> @Qualifier("xxx")로 하면 @Qualifier("xxx")로 빈에 똑같이 등록한것을 찾고, 없으면 xxx라는 빈을 찾아 넣어준다.
-> @Primary를 넣으면 우선순위가 최상위가 되어 이것을 바로 의존에 넣어준다.
=> @Qualifier와 @Primary가 동시에 있으면 @Qualifie가 우선순위를 가진다.(더 상세하기 때문)


-------------------------------------------------------------------------------------------------------------------------------------------

※ 8일차 ※

Alt + Enter : 스태틱 임폴트 단축키
Ctrl + Alt + B : 해당 인터페이스 구현체 찾기.

AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class, DiscountService.class);
하면 AnnotationConfigApplicationContext안에 적어준 클래스들을 빈으로 등록하여 의존 주입이 가능해진다.

자동 등록 빈 추천 :
- 업무 로직 빈 같은 컨트롤러, 서비스, 레포지토리 등 비즈니스 요구사항을 개발할때는 자동 등록을 추천함.
  수동 등록 빈 추천 :
- 기술 지원 빈 같은  AOP, 데이터베이스 연결, 공통 로그 처리 처럼 업무로직을 지원하기 위한 공통 기술(하부기술)등은 수동 등록을 추천함.

해당 인터페이스의 구현체들은 같은 패키지에 꼭 같이 묶어두자.!

데이터베이스 커넥션 풀 : 미리 서버와 DB를 커넥션을 미리 연결해두는것.

스프링 싱글톤 빈의 이벤트 라이프사이클 :
1. 스프링 컨테이너 생성
2. 스프링 빈 생성(생성자의 경우 이단계에서 주입이 됨.)
3. 의존관계 주입
4. 초기화 콜백(빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출됨)
5. 사용
6. 소멸전 콜백(빈이 소멸되기 직전에 호출됨.)
7. 스프링 컨테이너 종료
* 객체 생성시 생성자는 필수 정보를 받고 메모리를 할당해서 객체를 만드는데
  이후에 초기화 로직(커넥션 풀 생성 등)은 많이 무겁기 때문에 분리 하여주는게 좋다.
  (단 내부 값들만 약간 변경하는정도는 생성자에서 같이 하는편이 좋을수도 있다.)

빈의 라이프사이클 과정에서 의존주입이 완료된 다음과 빈이 소멸되기전에 실행하는 코드를 짜려면 다음과 같다.
Java에 있는 @PostConstruct나 @PreDestroy를 사용하는게 기본적이고,
외부 라이브러리에 초기화, 종료를 해야하면 @Bean에 직접 @Bean(initMethod = "init", destroyMethod = "close") 기능을 사용해보자.

-------------------------------------------------------------------------------------------------------------------------------------------

※ 9일차 ※

빈 스코프 : 스프링 빈이 존재할 수 있는 범위를 뜻한다.

스프링은 다양한 스코프를 지원한다.
- 싱글톤 스코프 : 스프링 컨테이너와 똑같은 생명주기를 가짐. (기본 스코프)
- 프로토타입 스코프 : 스프링 컨테이너가 프로토타입의 빈이면 빈을 생성하고 의존관계 주입까지만 관여하고 끝나는 매우 짧은 범위의 스코프이다.
- 웹 관련 스코프 : 스프링 웹과 관련된 기능이 들어갈때 사용.
  -> request : 고객의 요청이 들어와서 스프링 컨테이너를 호출할때 생성되고, 나갈때까지 유지되는 스코프이다.
  -> session : 웹 세션이 생성되고 종료될 때까지 유지되는 스코프이다.
  -> application : 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.

@Scope("xxx") 처럼 빈 스코프를 지정할 수 있다.
자동 등록이 되고 싶으면 @Component 위에, 수동 등록을 하고 싶으면 @Bean 위에 선언한다.

-------------------------------------------------------------------------------------------------------------------------------------------

※ 10일차 ※

프로토타입 빈 특징
- 스프링 컨테이너에 요청 할 때 마다 *새로 생성된다.
- 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.
- 그러므로 종료 메서드가 호출되지 않는다. (@PreDestroy등과 같은것들)
- 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.

Ctrl + Alt + N : 불필요한 변수 없애면서 합치기.
자바 유틸에 UUID.randomUUID().toString() 하면 절때 겹치지 않는 ID를 받을 수 있다.

DL(Dependency Lookup) : 의존관계 조회(탐색)이다.
DI 대신 DL을 사용하고 싶을때에는 컨테이너에서 대신 찾아주는 서비스들이 있다. (ObjectProvider, JSR-330 Provider)

ObjectProvider : 스프링에서만 지원 하는 기능으로 별도로 라이브러리를 추가하지 않아도 된다.(기존의 ObjectFactory를 확장한것.)
- getObject()을 호출하면 내부에서 스프링 컨테이너를 통해 빈을 찾아서 반환한다.(이때 하는것은 DL)
  JSR-330 Provider : 자바 표준이지만 gradle 라이브러리에 implementation 'javax.inject:javax.inject:1'를 추가하여 주어야 한다.

Web 스코프
-> request : 고객의 요청이 들어와서 스프링 컨테이너를 호출할때 생성되고, 나갈때까지 유지되는 스코프이다.
-> session : 웹 세션이 생성되고 종료될 때까지 유지되는 스코프이다.
-> application : 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.


Request scope를 사용할 때에는 실제 고객의 조회가 들어와야 생성할 빈의 값을 알 수가 있는데 이를 위해 빈의 생성을 지연해야한다.
그 방법으로는
ObjectProvider를 사용할수도 있고
ObjectProvider대신 proxyMode를 사용하여 빈의 등록을 지연 시킬수 있다.

proxyMode는 아래와 같이 proxyMode를 추가하여 주면 사용할 수 있다.
- @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
  -> 적용 대상이 인터페이스가 아닌 클래스면 TARGET_CLASS
  -> 적용 대상이 인터페이스면 INTERFACES

위와 같이 코드를 추가하여 주면 가짜 프록시 클래스를 만들고 스프링 컨테이너에 등록을 시킨다.(CGLIB라는 라이브러리 내 클래스를 상속받은 가짜 클래스)
해당 가짜 프록시 클래스에는 진짜 코드를 찾는 방법이 담겨있고,
실제 고객이 조회를 하게 되면 이 가짜 프록시 클래스가 진짜 request 스코프를 호출하여(위임) 지연 처리를 할 수 있게된다.
-> (가짜 프록시 객체는 실제 request scope와는 관계가 없다. 그냥 가짜이고, 내부에 단순한 위임 로직만 있고, 싱글톤 처럼 동작한다.)
-> 사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.
-> 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다.
-> 꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다.
